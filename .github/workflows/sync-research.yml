name: Sync Research to Vercel Blob

on:
  workflow_dispatch: # Allows manual triggering
  repository_dispatch:
    types: [sync-research] # Triggered when research repo pushes to main
  schedule:
    # Run daily at midnight UTC to check for updates (backup)
    - cron: '0 0 * * *'

jobs:
  sync-research:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: write

    steps:
      - name: Checkout website repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Checkout research repository
        uses: actions/checkout@v4
        with:
          repository: ${{ secrets.PAPERS_REPO }}
          token: ${{ secrets.PAPERS_TOKEN }}
          path: research-repo

      - name: Extract LaTeX Metadata
        run: |
          npm run extract-metadata research-repo || echo "Metadata extraction failed, continuing..."

      - name: Upload metadata and PDFs to Vercel Blob
        env:
          BLOB_READ_WRITE_TOKEN: ${{ secrets.BLOB_READ_WRITE_TOKEN }}
          PAPERS_REPO: ${{ secrets.PAPERS_REPO }}
        run: |
          # Create sync script
          cat > sync-research.js << 'EOF'
          import { put } from '@vercel/blob';
          import fs from 'fs';
          import path from 'path';
          import { fileURLToPath } from 'url';
          
          const __filename = fileURLToPath(import.meta.url);
          const __dirname = path.dirname(__filename);
          
          const researchDir = path.join(process.cwd(), 'research-repo');
          const metadataDir = path.join(process.cwd(), 'content', 'research');
          const blobToken = process.env.BLOB_READ_WRITE_TOKEN;
          
          if (!blobToken) {
            console.error('BLOB_READ_WRITE_TOKEN is not set');
            process.exit(1);
          }
          
          async function uploadMetadata() {
            try {
              if (!fs.existsSync(metadataDir)) {
                console.log('No metadata directory found, skipping metadata upload');
                return;
              }
              
              const metadataFiles = fs.readdirSync(metadataDir).filter(f => f.endsWith('.md'));
              console.log(`Found ${metadataFiles.length} metadata files`);
              
              for (const file of metadataFiles) {
                const filePath = path.join(metadataDir, file);
                const content = fs.readFileSync(filePath, 'utf8');
                const blobPath = `research/metadata/${file}`;
                
                console.log(`Uploading metadata ${file} to ${blobPath}...`);
                
                try {
                  await put(blobPath, content, {
                    access: 'public',
                    contentType: 'text/markdown',
                    addRandomSuffix: false,
                    token: blobToken,
                  });
                  console.log(`✓ Successfully uploaded metadata ${file}`);
                } catch (error) {
                  console.error(`✗ Failed to upload metadata ${file}:`, error.message);
                }
              }
              
              console.log('Metadata upload completed');
            } catch (error) {
              console.error('Error uploading metadata:', error);
              // Don't exit - continue with PDF sync
            }
          }
          
          async function syncPDFs() {
            try {
              // Find all PDF files in the research repo
              const findPDFs = (dir, fileList = []) => {
                const files = fs.readdirSync(dir);
                files.forEach(file => {
                  const filePath = path.join(dir, file);
                  const stat = fs.statSync(filePath);
                  if (stat.isDirectory()) {
                    findPDFs(filePath, fileList);
                  } else if (file.endsWith('.pdf')) {
                    fileList.push(filePath);
                  }
                });
                return fileList;
              };
              
              const pdfFiles = findPDFs(researchDir);
              console.log(`Found ${pdfFiles.length} PDF files`);
              
              for (const pdfPath of pdfFiles) {
                const relativePath = path.relative(researchDir, pdfPath);
                const blobPath = `research/${relativePath}`;
                const pdfBuffer = fs.readFileSync(pdfPath);
                
                console.log(`Uploading ${relativePath} to ${blobPath}...`);
                
                try {
                  await put(blobPath, pdfBuffer, {
                    access: 'public',
                    contentType: 'application/pdf',
                    addRandomSuffix: false,
                    token: blobToken,
                  });
                  console.log(`✓ Successfully uploaded ${relativePath}`);
                } catch (error) {
                  console.error(`✗ Failed to upload ${relativePath}:`, error.message);
                }
              }
              
              console.log('PDF sync completed');
            } catch (error) {
              console.error('Error syncing PDFs:', error);
              process.exit(1);
            }
          }
          
          // Await the async functions to ensure everything is synced before script exits
          (async () => {
            try {
              await uploadMetadata();
              await syncPDFs();
            } catch (error) {
              console.error('Failed to sync:', error);
              process.exit(1);
            }
          })();
          EOF
          
          node sync-research.js

      - name: Trigger Vercel deployment (optional)
        if: env.VERCEL_TOKEN != ''
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_USER_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
        run: |
          npx vercel --token $VERCEL_TOKEN --prod --yes || echo "Deployment trigger failed (this is optional)"

